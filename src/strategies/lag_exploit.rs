use crate::config::StrategyConfig;
use crate::models::market::{LifecyclePhase, Market, OrderBook, Side};
use crate::models::order::{OrderIntent, OrderSide, OrderType};
use crate::models::signal::VolRegime;
use crate::signals::probability::ProbabilityModel;
use rust_decimal::Decimal;
use tracing::info;

/// Cross-exchange lag exploit engine.
///
/// Compares Binance real-time price against Polymarket implied probability.
/// When Polymarket lags Binance by >3 cents, buys the underpriced side.
/// Our latency: ~500ms total. Average competitor: 5-60 seconds.
pub struct LagExploitEngine {
    config: StrategyConfig,
    prob_model: ProbabilityModel,
}

impl LagExploitEngine {
    pub fn new(config: StrategyConfig) -> Self {
        Self {
            config,
            prob_model: ProbabilityModel::new(),
        }
    }

    /// Evaluate lag exploit opportunity.
    ///
    /// - `binance_price`: current real-time price from Binance WebSocket
    /// - `open_price`: the market's reference price at open
    /// - `momentum_adj`: momentum adjustment from bias detector [-0.1, 0.1]
    pub fn evaluate(
        &self,
        market: &Market,
        yes_book: &OrderBook,
        no_book: &OrderBook,
        binance_price: f64,
        vol_regime: VolRegime,
        available_capital: f64,
        momentum_adj: f64,
    ) -> Vec<OrderIntent> {
        let phase = market.lifecycle_phase();

        // Only trade in appropriate phases
        if !matches!(
            phase,
            LifecyclePhase::EarlyArbs
                | LifecyclePhase::PrimeZone
                | LifecyclePhase::MaturePhase
        ) {
            return Vec::new();
        }

        // Check volatility filter
        if !self.should_trade(vol_regime, market) {
            return Vec::new();
        }

        let min_edge = match vol_regime.lag_min_edge() {
            Some(e) => e,
            None => return Vec::new(), // DEAD vol = no lag trading
        };

        let time_remaining_min = market.time_remaining_secs() / 60.0;
        let vol_per_min = market.asset.vol_per_minute();

        // Calculate fair probability from Binance price
        let fair_prob_up = self.prob_model.fair_prob_up(
            binance_price,
            market.reference_price,
            time_remaining_min,
            vol_per_min,
            momentum_adj,
        );
        let fair_prob_down = 1.0 - fair_prob_up;

        // Get market prices
        let yes_ask = match yes_book.best_ask() {
            Some((p, _)) => p.to_string().parse::<f64>().unwrap_or(1.0),
            None => return Vec::new(),
        };
        let no_ask = match no_book.best_ask() {
            Some((p, _)) => p.to_string().parse::<f64>().unwrap_or(1.0),
            None => return Vec::new(),
        };

        // Calculate mispricing
        let yes_mispricing = fair_prob_up - yes_ask;
        let no_mispricing = fair_prob_down - no_ask;

        let mut orders = Vec::new();

        if yes_mispricing > min_edge {
            if let Some(order) = self.build_lag_order(
                market,
                Side::Yes,
                &market.yes_token_id,
                yes_ask,
                yes_mispricing,
                fair_prob_up,
                vol_regime,
                available_capital,
                time_remaining_min,
            ) {
                orders.push(order);
            }
        } else if no_mispricing > min_edge {
            if let Some(order) = self.build_lag_order(
                market,
                Side::No,
                &market.no_token_id,
                no_ask,
                no_mispricing,
                fair_prob_down,
                vol_regime,
                available_capital,
                time_remaining_min,
            ) {
                orders.push(order);
            }
        }

        orders
    }

    fn build_lag_order(
        &self,
        market: &Market,
        side: Side,
        token_id: &str,
        ask_price: f64,
        mispricing: f64,
        fair_prob: f64,
        vol_regime: VolRegime,
        available_capital: f64,
        time_remaining_min: f64,
    ) -> Option<OrderIntent> {
        // Kelly sizing
        let base_win_prob = 0.62; // Conservative base from backtests
        let kelly_frac = self.prob_model.kelly_size(
            mispricing,
            ask_price,
            base_win_prob,
            self.config.lag_kelly_fraction,
        );

        if kelly_frac <= 0.0 {
            return None;
        }

        let mut size = available_capital * kelly_frac;

        // Reduce size in last minute
        if time_remaining_min < 1.0 {
            size *= 0.5;
        }

        // Cap by vol regime
        let max_size = available_capital * vol_regime.position_size_cap();
        size = size.min(max_size);

        if size < 0.10 {
            return None;
        }

        let side_str = match side {
            Side::Yes => "YES",
            Side::No => "NO",
        };

        info!(
            "LAG EXPLOIT: market={} buy {side_str}@{ask_price:.3} mispricing={mispricing:.3} fair={fair_prob:.3} size={size:.1}",
            market.slug
        );

        Some(OrderIntent {
            token_id: token_id.to_string(),
            market_side: side,
            order_side: OrderSide::Buy,
            price: Decimal::from_f64_retain(ask_price).unwrap_or(Decimal::ZERO),
            size: Decimal::from_f64_retain(size).unwrap_or(Decimal::ZERO),
            order_type: OrderType::FAK,
            post_only: false,
            expiration: None,
            strategy_tag: "lag_exploit".into(),
        })
    }

    fn should_trade(&self, vol_regime: VolRegime, market: &Market) -> bool {
        let time_remaining = market.time_remaining_secs();

        match vol_regime {
            VolRegime::Dead => false,
            VolRegime::High if time_remaining < 60.0 => false,
            VolRegime::Extreme if time_remaining < 120.0 => false,
            _ => time_remaining > 30.0,
        }
    }
}
